<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang Note | Jyu'Log</title>
<meta name=keywords content="Golang,Note,Tech"><meta name=description content='
note of golang, shared publicly

Go有一些不错的设计，虽然不能重载函数/运算符(感觉用久了会把OOP的东西忘完x)



Tour
learned from: https://go.dev/tour
Basics

package & import

like this:
package main

import (
    "fmt"
    "math/rand"
)

func main() {
    rand.Seed(233)
    fmt.Println("My favorite number is", rand.Intn(10))
}



export

大写开头 意味着export
对于import的包，也只能访问其中export(大写的)成员

like math.Pi




go 的类型声明在变量名后面！

可以认为是python的写法去掉冒号

func add(x int, y int) int {
    return x + y
}

官方解释：Go&rsquo;s Declaration Syntax - The Go Programming Language

简要概括：

C:
// an argument is func pointer
int (*fp)(int (*)(int, int), int)
// also return func pointer
int (*(*fp)(int (*)(int, int), int))(int, int)

Go:
f func(func(int,int) int, int) int
f func(func(int,int) int, int) func(int, int) int

read from left to right (C read in spiral)
cast(类型转化) 类型也不用打括号了 like []int("hi")  (不过后面的值还是得打括号)

除非有指针 (*int)(nil)
如果*也放到int后面，那就完全符合这套规范了
但Golang没做那么彻底






(x int, y int) 还可以简写成 (x, y int)


支持匹配的写法

a, b := swap("hello", "world")
返回值可以有多个
func swap(x, y string) (string, string) {
    return y, x
}



Named return values - 返回值可以有对应的变量声明(但要括起来)
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return // naked return
}

naked return 表示按照声明过的 (x, y int) 进行返回

但是不建议在长函数中用，会影响可读性




var 声明变量，也能类型推导；

注意多个变量的初始化只统一在中间写一个等号
var也可以打个括号来省去书写，类似import的写法
没初始化的值会赋零(对应的Zero Value) (让我想起solidity)

string和boolean则是 "" 和 false  (of course)



var i, j int = 1, 2
var c, python, java = true, false, "no!"
var (
    ToBe   bool       = false
    MaxInt uint64     = 1<<64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)

const 常量：把 var 换成 const 即可

const is high-precision values

{{ 存多大都行，可以超出64bit (如 1<<100)


const的类型会根据上下文自己变

{{ 感觉可以说是和 C 里 #define 的宏等效



package main

import "fmt"

const (
    // Create a huge number by shifting a 1 bit left 100 places.
    // In other words, the binary number that is 1 followed by 100 zeroes.
    Big = 1 << 100
    // Shift it right again 99 places, so we end up with 1<<1, or 2.
    Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
    return x * 0.1
}

func main() {
    fmt.Println(needInt(Small))
    fmt.Println(needInt(Big))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
}

Short variable declarations

k := 3
只允许在函数内使用，需要初始化来进行类型推导


Basic types
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128

可以用 %T 来输出类型， %v 来输出值
like: fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)


type conversions (cast)

T(v)


loop

只有一个loop结构： for
不用括号括起来
传统for格式
只有 ; 分隔

for i := 0; i < 10; i++ {
    sum += i
}

传统while格式
{{ 也就是while写成了for，并且不写括号

sum := 1
for sum < 1000 {
    sum += sum
}

传统while(true) / forever 格式

for {
}

if

也没括号
但还有在判断前加一句执行语句的新奇if
这个语句定义的变量所在scope持续到 if 结束(包括后续的else)
{{ 正适合不想一个东西算两遍的场景

// 传统
if x < 0 {
    ...
}
// 维新
if y := x-100; y < 0 {
    ...
} else {
    ...
}

switch

只执行一个case，不用写break
cases 不需要是 const int
{{ 好文明，好文明

fmt.Print("Go runs on ")
switch os := runtime.GOOS; os {
case "darwin":
    fmt.Println("OS X.")
case "linux":
    fmt.Println("Linux.")
default:
    // freebsd, openbsd, plan9, windows...
    fmt.Printf("%s.\n", os)
}

从上到下执行，遇到匹配的就进去 (不会再执行后面case判断的计算)
switch with no condition
a clean way to write long if-then-else chains
因为现在case可以是判断语句了

t := time.Now()
switch {
case t.Hour() < 12:
    fmt.Println("Good morning!")
case t.Hour() < 17:
    fmt.Println("Good afternoon.")
default:
    fmt.Println("Good evening.")
}

defer

压栈，推迟执行到scope结束
也因此是last-in-first-out
(pop 是 push 的倒序)
顺序上，是在 return 后执行

func main() {
    fmt.Println("counting")

    for i := 0; i < 10; i++ {
        **defer fmt.Println(i)**
    }

    fmt.Println("done")
}

// 这个的输出是9 8 7 … 0

只能defer函数调用
但结合匿名函数就等于没限制, like:

defer func() {
    // whatever
} ()


more types: structs, slices, and maps.'><meta name=author content="Asilvorcarp"><link rel=canonical href=http://localhost:1313/posts/golang-notes/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/golang-notes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="http://localhost:1313/posts/golang-notes/"><meta property="og:site_name" content="Jyu'Log"><meta property="og:title" content="Golang Note"><meta property="og:description" content=' note of golang, shared publicly Go有一些不错的设计，虽然不能重载函数/运算符(感觉用久了会把OOP的东西忘完x) Tour learned from: https://go.dev/tour
Basics package & import like this: package main import ( "fmt" "math/rand" ) func main() { rand.Seed(233) fmt.Println("My favorite number is", rand.Intn(10)) } export 大写开头 意味着export 对于import的包，也只能访问其中export(大写的)成员 like math.Pi go 的类型声明在变量名后面！ 可以认为是python的写法去掉冒号 func add(x int, y int) int { return x + y } 官方解释：Go’s Declaration Syntax - The Go Programming Language 简要概括： C: // an argument is func pointer int (*fp)(int (*)(int, int), int) // also return func pointer int (*(*fp)(int (*)(int, int), int))(int, int) Go: f func(func(int,int) int, int) int f func(func(int,int) int, int) func(int, int) int read from left to right (C read in spiral) cast(类型转化) 类型也不用打括号了 like []int("hi") (不过后面的值还是得打括号) 除非有指针 (*int)(nil) 如果*也放到int后面，那就完全符合这套规范了 但Golang没做那么彻底 (x int, y int) 还可以简写成 (x, y int) 支持匹配的写法 a, b := swap("hello", "world") 返回值可以有多个 func swap(x, y string) (string, string) { return y, x } Named return values - 返回值可以有对应的变量声明(但要括起来) func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return // naked return } naked return 表示按照声明过的 (x, y int) 进行返回 但是不建议在长函数中用，会影响可读性 var 声明变量，也能类型推导； 注意多个变量的初始化只统一在中间写一个等号 var也可以打个括号来省去书写，类似import的写法 没初始化的值会赋零(对应的Zero Value) (让我想起solidity) string和boolean则是 "" 和 false (of course) var i, j int = 1, 2 var c, python, java = true, false, "no!" var ( ToBe bool = false MaxInt uint64 = 1<<64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) const 常量：把 var 换成 const 即可 const is high-precision values {{ 存多大都行，可以超出64bit (如 1<<100) const的类型会根据上下文自己变 {{ 感觉可以说是和 C 里 #define 的宏等效 package main import "fmt" const ( // Create a huge number by shifting a 1 bit left 100 places. // In other words, the binary number that is 1 followed by 100 zeroes. Big = 1 << 100 // Shift it right again 99 places, so we end up with 1<<1, or 2. Small = Big >> 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needInt(Big)) fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) } Short variable declarations k := 3 只允许在函数内使用，需要初始化来进行类型推导 Basic types bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 可以用 %T 来输出类型， %v 来输出值 like: fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt) type conversions (cast) T(v) loop 只有一个loop结构： for 不用括号括起来 传统for格式 只有 ; 分隔 for i := 0; i < 10; i++ { sum += i } 传统while格式 {{ 也就是while写成了for，并且不写括号 sum := 1 for sum < 1000 { sum += sum } 传统while(true) / forever 格式 for { } if 也没括号 但还有在判断前加一句执行语句的新奇if 这个语句定义的变量所在scope持续到 if 结束(包括后续的else) {{ 正适合不想一个东西算两遍的场景 // 传统 if x < 0 { ... } // 维新 if y := x-100; y < 0 { ... } else { ... } switch 只执行一个case，不用写break cases 不需要是 const int {{ 好文明，好文明 fmt.Print("Go runs on ") switch os := runtime.GOOS; os { case "darwin": fmt.Println("OS X.") case "linux": fmt.Println("Linux.") default: // freebsd, openbsd, plan9, windows... fmt.Printf("%s.\n", os) } 从上到下执行，遇到匹配的就进去 (不会再执行后面case判断的计算) switch with no condition a clean way to write long if-then-else chains 因为现在case可以是判断语句了 t := time.Now() switch { case t.Hour() < 12: fmt.Println("Good morning!") case t.Hour() < 17: fmt.Println("Good afternoon.") default: fmt.Println("Good evening.") } defer 压栈，推迟执行到scope结束 也因此是last-in-first-out (pop 是 push 的倒序) 顺序上，是在 return 后执行 func main() { fmt.Println("counting") for i := 0; i < 10; i++ { **defer fmt.Println(i)** } fmt.Println("done") } // 这个的输出是9 8 7 … 0 只能defer函数调用 但结合匿名函数就等于没限制, like: defer func() { // whatever } () more types: structs, slices, and maps.'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-12-09T19:53:33+05:30"><meta property="article:modified_time" content="2022-12-09T19:53:33+05:30"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Note"><meta property="article:tag" content="Tech"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang Note"><meta name=twitter:description content='
note of golang, shared publicly

Go有一些不错的设计，虽然不能重载函数/运算符(感觉用久了会把OOP的东西忘完x)



Tour
learned from: https://go.dev/tour
Basics

package & import

like this:
package main

import (
    "fmt"
    "math/rand"
)

func main() {
    rand.Seed(233)
    fmt.Println("My favorite number is", rand.Intn(10))
}



export

大写开头 意味着export
对于import的包，也只能访问其中export(大写的)成员

like math.Pi




go 的类型声明在变量名后面！

可以认为是python的写法去掉冒号

func add(x int, y int) int {
    return x + y
}

官方解释：Go&rsquo;s Declaration Syntax - The Go Programming Language

简要概括：

C:
// an argument is func pointer
int (*fp)(int (*)(int, int), int)
// also return func pointer
int (*(*fp)(int (*)(int, int), int))(int, int)

Go:
f func(func(int,int) int, int) int
f func(func(int,int) int, int) func(int, int) int

read from left to right (C read in spiral)
cast(类型转化) 类型也不用打括号了 like []int("hi")  (不过后面的值还是得打括号)

除非有指针 (*int)(nil)
如果*也放到int后面，那就完全符合这套规范了
但Golang没做那么彻底






(x int, y int) 还可以简写成 (x, y int)


支持匹配的写法

a, b := swap("hello", "world")
返回值可以有多个
func swap(x, y string) (string, string) {
    return y, x
}



Named return values - 返回值可以有对应的变量声明(但要括起来)
func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return // naked return
}

naked return 表示按照声明过的 (x, y int) 进行返回

但是不建议在长函数中用，会影响可读性




var 声明变量，也能类型推导；

注意多个变量的初始化只统一在中间写一个等号
var也可以打个括号来省去书写，类似import的写法
没初始化的值会赋零(对应的Zero Value) (让我想起solidity)

string和boolean则是 "" 和 false  (of course)



var i, j int = 1, 2
var c, python, java = true, false, "no!"
var (
    ToBe   bool       = false
    MaxInt uint64     = 1<<64 - 1
    z      complex128 = cmplx.Sqrt(-5 + 12i)
)

const 常量：把 var 换成 const 即可

const is high-precision values

{{ 存多大都行，可以超出64bit (如 1<<100)


const的类型会根据上下文自己变

{{ 感觉可以说是和 C 里 #define 的宏等效



package main

import "fmt"

const (
    // Create a huge number by shifting a 1 bit left 100 places.
    // In other words, the binary number that is 1 followed by 100 zeroes.
    Big = 1 << 100
    // Shift it right again 99 places, so we end up with 1<<1, or 2.
    Small = Big >> 99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
    return x * 0.1
}

func main() {
    fmt.Println(needInt(Small))
    fmt.Println(needInt(Big))
    fmt.Println(needFloat(Small))
    fmt.Println(needFloat(Big))
}

Short variable declarations

k := 3
只允许在函数内使用，需要初始化来进行类型推导


Basic types
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // alias for uint8

rune // alias for int32
     // represents a Unicode code point

float32 float64

complex64 complex128

可以用 %T 来输出类型， %v 来输出值
like: fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)


type conversions (cast)

T(v)


loop

只有一个loop结构： for
不用括号括起来
传统for格式
只有 ; 分隔

for i := 0; i < 10; i++ {
    sum += i
}

传统while格式
{{ 也就是while写成了for，并且不写括号

sum := 1
for sum < 1000 {
    sum += sum
}

传统while(true) / forever 格式

for {
}

if

也没括号
但还有在判断前加一句执行语句的新奇if
这个语句定义的变量所在scope持续到 if 结束(包括后续的else)
{{ 正适合不想一个东西算两遍的场景

// 传统
if x < 0 {
    ...
}
// 维新
if y := x-100; y < 0 {
    ...
} else {
    ...
}

switch

只执行一个case，不用写break
cases 不需要是 const int
{{ 好文明，好文明

fmt.Print("Go runs on ")
switch os := runtime.GOOS; os {
case "darwin":
    fmt.Println("OS X.")
case "linux":
    fmt.Println("Linux.")
default:
    // freebsd, openbsd, plan9, windows...
    fmt.Printf("%s.\n", os)
}

从上到下执行，遇到匹配的就进去 (不会再执行后面case判断的计算)
switch with no condition
a clean way to write long if-then-else chains
因为现在case可以是判断语句了

t := time.Now()
switch {
case t.Hour() < 12:
    fmt.Println("Good morning!")
case t.Hour() < 17:
    fmt.Println("Good afternoon.")
default:
    fmt.Println("Good evening.")
}

defer

压栈，推迟执行到scope结束
也因此是last-in-first-out
(pop 是 push 的倒序)
顺序上，是在 return 后执行

func main() {
    fmt.Println("counting")

    for i := 0; i < 10; i++ {
        **defer fmt.Println(i)**
    }

    fmt.Println("done")
}

// 这个的输出是9 8 7 … 0

只能defer函数调用
但结合匿名函数就等于没限制, like:

defer func() {
    // whatever
} ()


more types: structs, slices, and maps.'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Golang Note","item":"http://localhost:1313/posts/golang-notes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang Note","name":"Golang Note","description":" note of golang, shared publicly Go有一些不错的设计，虽然不能重载函数/运算符(感觉用久了会把OOP的东西忘完x) Tour learned from: https://go.dev/tour\nBasics package \u0026amp; import like this: package main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { rand.Seed(233) fmt.Println(\u0026#34;My favorite number is\u0026#34;, rand.Intn(10)) } export 大写开头 意味着export 对于import的包，也只能访问其中export(大写的)成员 like math.Pi go 的类型声明在变量名后面！ 可以认为是python的写法去掉冒号 func add(x int, y int) int { return x + y } 官方解释：Go\u0026rsquo;s Declaration Syntax - The Go Programming Language 简要概括： C: // an argument is func pointer int (*fp)(int (*)(int, int), int) // also return func pointer int (*(*fp)(int (*)(int, int), int))(int, int) Go: f func(func(int,int) int, int) int f func(func(int,int) int, int) func(int, int) int read from left to right (C read in spiral) cast(类型转化) 类型也不用打括号了 like []int(\u0026quot;hi\u0026quot;) (不过后面的值还是得打括号) 除非有指针 (*int)(nil) 如果*也放到int后面，那就完全符合这套规范了 但Golang没做那么彻底 (x int, y int) 还可以简写成 (x, y int) 支持匹配的写法 a, b := swap(\u0026quot;hello\u0026quot;, \u0026quot;world\u0026quot;) 返回值可以有多个 func swap(x, y string) (string, string) { return y, x } Named return values - 返回值可以有对应的变量声明(但要括起来) func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return // naked return } naked return 表示按照声明过的 (x, y int) 进行返回 但是不建议在长函数中用，会影响可读性 var 声明变量，也能类型推导； 注意多个变量的初始化只统一在中间写一个等号 var也可以打个括号来省去书写，类似import的写法 没初始化的值会赋零(对应的Zero Value) (让我想起solidity) string和boolean则是 \u0026quot;\u0026quot; 和 false (of course) var i, j int = 1, 2 var c, python, java = true, false, \u0026#34;no!\u0026#34; var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) const 常量：把 var 换成 const 即可 const is high-precision values {{ 存多大都行，可以超出64bit (如 1\u0026lt;\u0026lt;100) const的类型会根据上下文自己变 {{ 感觉可以说是和 C 里 #define 的宏等效 package main import \u0026#34;fmt\u0026#34; const ( // Create a huge number by shifting a 1 bit left 100 places. // In other words, the binary number that is 1 followed by 100 zeroes. Big = 1 \u0026lt;\u0026lt; 100 // Shift it right again 99 places, so we end up with 1\u0026lt;\u0026lt;1, or 2. Small = Big \u0026gt;\u0026gt; 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needInt(Big)) fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) } Short variable declarations k := 3 只允许在函数内使用，需要初始化来进行类型推导 Basic types bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 可以用 %T 来输出类型， %v 来输出值 like: fmt.Printf(\u0026quot;Type: %T Value: %v\\n\u0026quot;, MaxInt, MaxInt) type conversions (cast) T(v) loop 只有一个loop结构： for 不用括号括起来 传统for格式 只有 ; 分隔 for i := 0; i \u0026lt; 10; i++ { sum += i } 传统while格式 {{ 也就是while写成了for，并且不写括号 sum := 1 for sum \u0026lt; 1000 { sum += sum } 传统while(true) / forever 格式 for { } if 也没括号 但还有在判断前加一句执行语句的新奇if 这个语句定义的变量所在scope持续到 if 结束(包括后续的else) {{ 正适合不想一个东西算两遍的场景 // 传统 if x \u0026lt; 0 { ... } // 维新 if y := x-100; y \u0026lt; 0 { ... } else { ... } switch 只执行一个case，不用写break cases 不需要是 const int {{ 好文明，好文明 fmt.Print(\u0026#34;Go runs on \u0026#34;) switch os := runtime.GOOS; os { case \u0026#34;darwin\u0026#34;: fmt.Println(\u0026#34;OS X.\u0026#34;) case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;Linux.\u0026#34;) default: // freebsd, openbsd, plan9, windows... fmt.Printf(\u0026#34;%s.\\n\u0026#34;, os) } 从上到下执行，遇到匹配的就进去 (不会再执行后面case判断的计算) switch with no condition a clean way to write long if-then-else chains 因为现在case可以是判断语句了 t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning!\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } defer 压栈，推迟执行到scope结束 也因此是last-in-first-out (pop 是 push 的倒序) 顺序上，是在 return 后执行 func main() { fmt.Println(\u0026#34;counting\u0026#34;) for i := 0; i \u0026lt; 10; i++ { **defer fmt.Println(i)** } fmt.Println(\u0026#34;done\u0026#34;) } // 这个的输出是9 8 7 … 0 只能defer函数调用 但结合匿名函数就等于没限制, like: defer func() { // whatever } () more types: structs, slices, and maps.\n","keywords":["Golang","Note","Tech"],"articleBody":" note of golang, shared publicly Go有一些不错的设计，虽然不能重载函数/运算符(感觉用久了会把OOP的东西忘完x) Tour learned from: https://go.dev/tour\nBasics package \u0026 import like this: package main import ( \"fmt\" \"math/rand\" ) func main() { rand.Seed(233) fmt.Println(\"My favorite number is\", rand.Intn(10)) } export 大写开头 意味着export 对于import的包，也只能访问其中export(大写的)成员 like math.Pi go 的类型声明在变量名后面！ 可以认为是python的写法去掉冒号 func add(x int, y int) int { return x + y } 官方解释：Go’s Declaration Syntax - The Go Programming Language 简要概括： C: // an argument is func pointer int (*fp)(int (*)(int, int), int) // also return func pointer int (*(*fp)(int (*)(int, int), int))(int, int) Go: f func(func(int,int) int, int) int f func(func(int,int) int, int) func(int, int) int read from left to right (C read in spiral) cast(类型转化) 类型也不用打括号了 like []int(\"hi\") (不过后面的值还是得打括号) 除非有指针 (*int)(nil) 如果*也放到int后面，那就完全符合这套规范了 但Golang没做那么彻底 (x int, y int) 还可以简写成 (x, y int) 支持匹配的写法 a, b := swap(\"hello\", \"world\") 返回值可以有多个 func swap(x, y string) (string, string) { return y, x } Named return values - 返回值可以有对应的变量声明(但要括起来) func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return // naked return } naked return 表示按照声明过的 (x, y int) 进行返回 但是不建议在长函数中用，会影响可读性 var 声明变量，也能类型推导； 注意多个变量的初始化只统一在中间写一个等号 var也可以打个括号来省去书写，类似import的写法 没初始化的值会赋零(对应的Zero Value) (让我想起solidity) string和boolean则是 \"\" 和 false (of course) var i, j int = 1, 2 var c, python, java = true, false, \"no!\" var ( ToBe bool = false MaxInt uint64 = 1\u003c\u003c64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) const 常量：把 var 换成 const 即可 const is high-precision values {{ 存多大都行，可以超出64bit (如 1\u003c\u003c100) const的类型会根据上下文自己变 {{ 感觉可以说是和 C 里 #define 的宏等效 package main import \"fmt\" const ( // Create a huge number by shifting a 1 bit left 100 places. // In other words, the binary number that is 1 followed by 100 zeroes. Big = 1 \u003c\u003c 100 // Shift it right again 99 places, so we end up with 1\u003c\u003c1, or 2. Small = Big \u003e\u003e 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needInt(Big)) fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) } Short variable declarations k := 3 只允许在函数内使用，需要初始化来进行类型推导 Basic types bool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 可以用 %T 来输出类型， %v 来输出值 like: fmt.Printf(\"Type: %T Value: %v\\n\", MaxInt, MaxInt) type conversions (cast) T(v) loop 只有一个loop结构： for 不用括号括起来 传统for格式 只有 ; 分隔 for i := 0; i \u003c 10; i++ { sum += i } 传统while格式 {{ 也就是while写成了for，并且不写括号 sum := 1 for sum \u003c 1000 { sum += sum } 传统while(true) / forever 格式 for { } if 也没括号 但还有在判断前加一句执行语句的新奇if 这个语句定义的变量所在scope持续到 if 结束(包括后续的else) {{ 正适合不想一个东西算两遍的场景 // 传统 if x \u003c 0 { ... } // 维新 if y := x-100; y \u003c 0 { ... } else { ... } switch 只执行一个case，不用写break cases 不需要是 const int {{ 好文明，好文明 fmt.Print(\"Go runs on \") switch os := runtime.GOOS; os { case \"darwin\": fmt.Println(\"OS X.\") case \"linux\": fmt.Println(\"Linux.\") default: // freebsd, openbsd, plan9, windows... fmt.Printf(\"%s.\\n\", os) } 从上到下执行，遇到匹配的就进去 (不会再执行后面case判断的计算) switch with no condition a clean way to write long if-then-else chains 因为现在case可以是判断语句了 t := time.Now() switch { case t.Hour() \u003c 12: fmt.Println(\"Good morning!\") case t.Hour() \u003c 17: fmt.Println(\"Good afternoon.\") default: fmt.Println(\"Good evening.\") } defer 压栈，推迟执行到scope结束 也因此是last-in-first-out (pop 是 push 的倒序) 顺序上，是在 return 后执行 func main() { fmt.Println(\"counting\") for i := 0; i \u003c 10; i++ { **defer fmt.Println(i)** } fmt.Println(\"done\") } // 这个的输出是9 8 7 … 0 只能defer函数调用 但结合匿名函数就等于没限制, like: defer func() { // whatever } () more types: structs, slices, and maps.\npointer pointer 的 zero value 是 nil 什么年代还在写传统null \u0026 * 的操作与C一致 但不允许指针算数 (pointer arithmetic) struct 注意前三句的语法 指向struct的指针，访问field不用 -\u003e ，仍然用 . **type Vertex struct { X int Y int } v1 := Vertex{1, 2} v2 := Vertex{X: 1}** p := \u0026v1 **p.X** = 1e9 // not p-\u003eX fmt.Println(v) array [n]T fixed size 用作size定义时写在前面，用作index访问时写在后面 var a [2]string a[0] = \"Hello\" slice []T dynamically-sized 用 a[low : high] 来 refer to 一个array 省略 low/high 的 behavior 同 python, like s[2:] primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] // which is [3 5 7] 是个reference (对其改动也反映在the underlying array上) A slice does not store any data, it just describes a section of an underlying array. slice literals q := []int{2, 3, 5, 7, 11, 13} 这个的原理是先构造一个array，然后让slice refer to 它 len(s) cap(s) len 即 现在里面元素个数 cap 即 从现在的开头到结尾的个数 func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:0] printSlice(s) // Extend its length. s = s[:4] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) } func printSlice(s []int) { fmt.Printf(\"len=%d cap=%d %v\\n\", len(s), cap(s), s) } /* len=6 cap=6 [2 3 5 7 11 13] len=0 cap=6 [] len=4 cap=6 [2 3 5 7] len=2 cap=4 [5 7] */ 空值也是 nil length and capacity of 0 has no underlying array. make(s []T, len, cap) []T allocates a zeroed array and returns a slice that refers to that array (最终作用类似C的malloc) (cap可以省略) b := make([]int, 0, 5) // len(b)=0, cap(b)=5 b = b[:cap(b)] // len(b)=5, cap(b)=5 b = b[1:] // len(b)=4, cap(b)=4 append(s []T, vs ...T) []T **s = append(s, 2, 3, 4)** 如果空间不够会创建个更大的array {{ 这里的写法感觉类似函数式编程 (append不会直接在s上做修改) 详细说明见：documentation of the built-in package range 用range实现遍历 slice/map 每次迭代都给一对：index, value 类似python，不想要的可以用 _ 来作placeholder 如果只写一个，得到的是index而非value (因为i在左) for i := range pow var a = []int{1, 2, 4, 8, 16, 32, 64, 128} for i, v := range a { fmt.Printf(\"2**%d = %d\\n\", i, v) } /* 2**0 = 1 2**1 = 2 2**2 = 4 2**3 = 8 ... */ map 和slice一样，也是个reference 空值也是 nil which has no keys, nor can keys be added. 类型声明 map[kT]vT m := make(map[string]Vertex) m[\"Bell Labs\"] = Vertex{ 40.68433, -74.39967, } fmt.Println(m[\"Bell Labs\"]) Insert or update an element in map m: m[key] = elem Retrieve an element: elem = m[key] Delete an element: delete(m, key)** Test that a key is present with a two-value assignment: elem, ok := m[key] ok : true when key is in m Func closure 闭包 A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is “bound” to the variables. {{ 感觉最终效果上就是能生成多个有自己的static var的函数 package main import \"fmt\" func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u003c 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } } /* 0 0 1 -2 3 -6 6 -12 10 -20 15 -30 ... */ // for fibonacci (0, 1, 1, 2, 3, 5, ...) func fibonacci() func() int { a := 0 b := 1 return func() int { oldA := a a, b = b, a + b return oldA } } func main() { f := fibonacci() for i := 0; i \u003c 10; i++ { fmt.Println(f()) } } 先跳过了 Methods and interfaces 写method记得加 * ，保证在原对象上操作，而非copy一个 Generics Concurrency go f(x, y, z) 启动新线程, called goroutine x, y, z 的执行发生在current goroutine f 的执行发生在new goroutine goroutine 运行在相同的 address space 因此需要 sync-ly 访问 shared mem channel chan // \"\\\\\"表示可选参数 ch := make(chan int, \\\\buf_len\\\\ ) ch \u003c- v // Send v, \\\\ok\\\\ := \u003c-ch // Receive and assign. // ok=false means channel closed. for i := range c // receives values from the channel // repeatedly **until it is closed.** close(ch) // close (better by sender, can be not necessary) By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables. channel如果不指定buffer， 必须要sender和receiver同时在等待的时候才能完成一次传输 // error code (dead lock) test := **make(chan int)** test \u003c- 1 fmt.Println( \u003c- test ) // good code test := **make(chan int, 1)** test \u003c- 1 fmt.Println( \u003c- test ) Q: 如果需要无限可拓展的buf怎么办？ chan的元素类型改成数组？ select select { case c \u003c- x: x, y = y, x+y case \u003c-quit: fmt.Println(\"quit\") return } // 跑一个匿名函数 go func() { for i := 0; i \u003c 10; i++ { fmt.Println(\u003c-c) } quit \u003c- 0 }() case 语句都是 communication operations select 会等到有可以run的，等到了就执行 (如果多个都可以run，那就随机选) 可以有 default: select { case i := \u003c-c: // use i default: // receiving from c would block } 一个channel范例程序 教程里的题目，自己写的代码 判断两个树的中序遍历是否相同 package main import \"golang.org/x/tour/tree\" /* type Tree struct { Left *Tree Value int Right *Tree } */ import \"fmt\" // Walk walks the tree t sending all values // from the tree to the channel ch. func Walk(t *tree.Tree, ch chan int) { recWalk(t, ch) close(ch) } func recWalk(t *tree.Tree, ch chan int) { if t == nil { return } recWalk(t.Left, ch) ch \u003c- t.Value recWalk(t.Right, ch) } // Same determines whether the trees // t1 and t2 contain the same values. func Same(t1, t2 *tree.Tree) bool { ch1 := make(chan int) ch2 := make(chan int) go Walk(t1, ch1) go Walk(t2, ch2) for { i, ok1 := \u003c- ch1 j, ok2 := \u003c- ch2 if ok1==false \u0026\u0026 ok2==false { // both closed return true } if (ok1||ok2) \u0026\u0026 !(ok1\u0026\u0026ok2) { // not same length return false } fmt.Print(\"i: \") // for debug fmt.Print(i) // for debug fmt.Print(\", j: \") // for debug fmt.Println(j) // for debug if i!=j { return false } } } func main() { res := Same(tree.New(1), tree.New(2)) fmt.Println(res) res = Same(tree.New(1), tree.New(1)) fmt.Println(res) res = Same(tree.New(2), tree.New(2)) fmt.Println(res) } sync.Mutex 提供了两个方法 Lock Unlock (包含的部分即原子化) 可以利用 defer 把return语句也包含在原子操作里 (例如下面的Value函数) package main import ( \"fmt\" \"sync\" \"time\" ) // SafeCounter is safe to use concurrently. type SafeCounter struct { mu sync.Mutex v map[string]int } **// Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mu.Unlock() } // Value returns the current value of the counter for the given key. func (c *SafeCounter) Value(key string) int { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mu.Unlock() return c.v[key] }** func main() { c := SafeCounter{v: make(map[string]int)} for i := 0; i \u003c 1000; i++ { go c.Inc(\"somekey\") } time.Sleep(time.Second) fmt.Println(c.Value(\"somekey\")) } 一个 channel \u0026 sync.Mutex 范例 A Tour of Go 教程里的一个并行 Web Crawler (网页爬虫) 这里 map 其实就当做 set 用了 语言内置类型好像是没有set的 但查到 golang-set 这个包还提供了线程安全的 set go 的 map 不是线程安全的 (not safe for concurrent use)， 需要一个mutex保护它 package main import ( \"fmt\" \"sync\" ) type Fetcher interface { // Fetch returns the body of URL and // a slice of URLs found on that page. Fetch(url string) (body string, urls []string, err error) } // Crawl uses fetcher to recursively crawl // pages starting with url, to a maximum of depth. func Crawl(url string, depth int, fetcher Fetcher) { m := make(map[string]bool) var mu sync.Mutex // protects the map done := make(chan bool) go recCrawl(url, depth, fetcher, m, \u0026mu, done) \u003c- done return } func recCrawl(url string, depth int, fetcher Fetcher, m map[string]bool, mu *sync.Mutex, done chan bool) { // defer真好用 defer func() { done \u003c- true fmt.Printf(\"--- done: %s\\n\", url) } () fmt.Printf(\"--- fetch: %s\\n\", url) mu.Lock() m[url] = true mu.Unlock() if depth \u003c= 0 { return } body, urls, err := fetcher.Fetch(url) if err != nil { fmt.Println(err) return } fmt.Printf(\"found: %s %q\\n\", url, body) _done := make(chan bool) needDone := 0 for _, u := range urls { mu.Lock() _, exist := m[u] mu.Unlock() // fmt.Printf(\"--- exist?: %V\\n\", exist) if exist { fmt.Printf(\"--- fetched before: %s\\n\", u) continue } fmt.Printf(\"--- to: %s\\n\", u) needDone++ go recCrawl(u, depth-1, fetcher, m, mu, _done) } for i:=0; i\u003cneedDone; i++ { \u003c- _done fmt.Printf(\"--- get one done: %d %s\\n\", i, url) } return } func main() { Crawl(\"https://golang.org/\", 4, fetcher) } // fakeFetcher is Fetcher that returns canned results. type fakeFetcher map[string]*fakeResult type fakeResult struct { body string urls []string } func (f fakeFetcher) Fetch(url string) (string, []string, error) { if res, ok := f[url]; ok { return res.body, res.urls, nil } return \"\", nil, fmt.Errorf(\"not found: %s\", url) } // fetcher is a populated fakeFetcher. var fetcher = fakeFetcher{ \"https://golang.org/\": \u0026fakeResult{ \"The Go Programming Language\", []string{ \"https://golang.org/pkg/\", \"https://golang.org/cmd/\", }, }, \"https://golang.org/pkg/\": \u0026fakeResult{ \"Packages\", []string{ \"https://golang.org/\", \"https://golang.org/cmd/\", \"https://golang.org/pkg/fmt/\", \"https://golang.org/pkg/os/\", }, }, \"https://golang.org/pkg/fmt/\": \u0026fakeResult{ \"Package fmt\", []string{ \"https://golang.org/\", \"https://golang.org/pkg/\", }, }, \"https://golang.org/pkg/os/\": \u0026fakeResult{ \"Package os\", []string{ \"https://golang.org/\", \"https://golang.org/pkg/\", }, }, } Go further Where to Go from here\nYou can get started by installing Go.\nOnce you have Go installed, the Go Documentation is a great place to continue. It contains references, tutorials, videos, and more.\nTo learn how to organize and work with Go code, read How to Write Go Code.\nIf you need help with the standard library, see the package reference. For help with the language itself, you might be surprised to find the Language Spec is quite readable.\nTo further explore Go’s concurrency model, watch Go Concurrency Patterns (slides) and Advanced Go Concurrency Patterns (slides) and read the Share Memory by Communicating codewalk.\nTo get started writing web applications, watch A simple programming environment (slides) and read the Writing Web Applications tutorial.\nThe First Class Functions in Go codewalk gives an interesting perspective on Go’s function types.\nThe Go Blog has a large archive of informative Go articles.\nVisit the Go home page for more.\nOther Some details fmt.Print 相关函数 Println Printf 输出控制 %v 对啥类型都适用 Tag 序列化中常用\nTODO: learn Tag原理 Golang 中的标签（Tags in Golang） - 知乎 (zhihu.com) Json中的Tag GoLang 中 Json Tag用法汇总 | 小武的博客 (fivezh.github.io) SQL数据库ORM中的Tag [GO] gorm的字段标签_我要努力向上的博客-CSDN博客_gorm tag Golang后端常⽤类库 配置⽂件：Viper 序列化：⾃带的 encoding/json 服务器框架：gin，echo等 数据库访问：go-mongo gorm等（之后会结合数据库章节细讲） ⽹络请求： http ⽇志系统：logrus Avoid Mem Leak Memory Leaking Scenarios -Go 101\nSubstrings Subslices Not resetting pointers in lost slice elements Hanging Goroutines 其他 not stopping time.Ticker values which are not used any more using finalizers improperly deferring function calls 问题排查：使用pprof Go程序内存泄露问题快速定位 - MySpace (hitzhangjie.pro) ","wordCount":"2282","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2022-12-09T19:53:33+05:30","dateModified":"2022-12-09T19:53:33+05:30","author":{"@type":"Person","name":"Asilvorcarp"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/golang-notes/"},"publisher":{"@type":"Organization","name":"Jyu'Log","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Jyu'Log (Alt + H)"><img src=http://localhost:1313/nope.png alt aria-label=logo height=35>Jyu'Log</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/ title=Posts><span>Posts</span></a></li><li><a href=http://localhost:1313/archive/ title=Archive><span>Archive</span></a></li><li><a href=http://localhost:1313/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=http://localhost:1313/tags/ title=Tags><span>Tags</span></a></li><li><a href=http://localhost:1313/faq/ title=FAQ><span>FAQ</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Golang Note
<span class=entry-hint title=Draft><svg height="35" viewBox="0 -960 960 960" fill="currentcolor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h1><div class=post-meta><span title='2022-12-09 19:53:33 +0530 +0530'>December 9, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Asilvorcarp&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/Golang%20Notes.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#basics>Basics</a></li><li><a href=#concurrency>Concurrency</a></li><li><a href=#go-further>Go further</a></li></ul><ul><li><a href=#some-details>Some details</a></li><li><a href=#tag>Tag</a></li><li><a href=#golang后端常类库>Golang后端常⽤类库</a></li><li><a href=#avoid-mem-leak>Avoid Mem Leak</a></li></ul></nav></div></details></div><div class=post-content><ul><li>note of golang, shared publicly<ul><li>Go有一些不错的设计，虽然不能重载函数/运算符(感觉用久了会把OOP的东西忘完x)</li></ul></li></ul><h1 id=tour>Tour<a hidden class=anchor aria-hidden=true href=#tour>#</a></h1><p>learned from: <a href=https://go.dev/tour>https://go.dev/tour</a></p><h2 id=basics>Basics<a hidden class=anchor aria-hidden=true href=#basics>#</a></h2><ul><li>package & import<ul><li>like this:<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>rand</span><span class=p>.</span><span class=nf>Seed</span><span class=p>(</span><span class=mi>233</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;My favorite number is&#34;</span><span class=p>,</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>10</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul></li><li>export<ul><li><strong>大写开头 意味着export</strong></li><li>对于import的包，也只能访问其中export(大写的)成员<ul><li>like <code>math.Pi</code></li></ul></li></ul></li><li><strong>go 的类型声明在变量名后面！</strong><ul><li>可以认为是python的写法去掉冒号</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>add</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>x</span> <span class=o>+</span> <span class=nx>y</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>官方解释：<a href=https://go.dev/blog/declaration-syntax>Go&rsquo;s Declaration Syntax - The Go Programming Language</a><ul><li>简要概括：<ul><li>C:<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// an argument is func pointer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=nx>fp</span><span class=p>)(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>),</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// also return func pointer
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=p>(</span><span class=o>*</span><span class=nx>fp</span><span class=p>)(</span><span class=kt>int</span> <span class=p>(</span><span class=o>*</span><span class=p>)(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>),</span> <span class=kt>int</span><span class=p>))(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span>
</span></span></code></pre></div></li><li>Go:<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span>
</span></span></code></pre></div></li><li>read from left to right (C read in spiral)</li><li>cast(类型转化) 类型也不用打括号了 like <code>[]int("hi")</code> (不过后面的值还是得打括号)<ul><li>除非有指针 <code>(*int)(nil)</code></li><li>如果<code>*</code>也放到<code>int</code>后面，那就完全符合这套规范了
但Golang没做那么彻底</li></ul></li></ul></li></ul></li><li><code>(x int, y int)</code> 还可以简写成 <code>(x, y int)</code></li></ul></li><li>支持匹配的写法<ul><li><code>a, b := swap("hello", "world")</code></li><li>返回值可以有多个<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>swap</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul></li><li>Named return values - 返回值可以有对应的变量声明(但要括起来)<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>split</span><span class=p>(</span><span class=nx>sum</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>x</span> <span class=p>=</span> <span class=nx>sum</span> <span class=o>*</span> <span class=mi>4</span> <span class=o>/</span> <span class=mi>9</span>
</span></span><span class=line><span class=cl>    <span class=nx>y</span> <span class=p>=</span> <span class=nx>sum</span> <span class=o>-</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=c1>// naked return
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>naked return 表示按照声明过的 <code>(x, y int)</code> 进行返回<ul><li>但是不建议在长函数中用，会影响可读性</li></ul></li></ul></li><li>var 声明变量，也能类型推导；<ul><li><strong>注意多个变量的初始化只统一在中间写一个等号</strong></li><li>var也可以打个括号来省去书写，类似import的写法</li><li><strong>没初始化的值会赋零(对应的Zero Value) (让我想起solidity)</strong><ul><li>string和boolean则是 <code>""</code> 和 <code>false</code> (of course)</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>j</span> <span class=kt>int</span> <span class=p>=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>c</span><span class=p>,</span> <span class=nx>python</span><span class=p>,</span> <span class=nx>java</span> <span class=p>=</span> <span class=kc>true</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=s>&#34;no!&#34;</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>ToBe</span>   <span class=kt>bool</span>       <span class=p>=</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>    <span class=nx>MaxInt</span> <span class=kt>uint64</span>     <span class=p>=</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>64</span> <span class=o>-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=nx>z</span>      <span class=kt>complex128</span> <span class=p>=</span> <span class=nx>cmplx</span><span class=p>.</span><span class=nf>Sqrt</span><span class=p>(</span><span class=o>-</span><span class=mi>5</span> <span class=o>+</span> <span class=m>12i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span></code></pre></div></li><li>const 常量：把 <code>var</code> 换成 <code>const</code> 即可<ul><li>const is high-precision values<ul><li>{{ 存多大都行，可以超出64bit (如 <code>1&lt;&lt;100</code>)</li></ul></li><li>const的类型会根据上下文自己变<ul><li>{{ 感觉可以说是和 C 里 <code>#define</code> 的宏等效</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Create a huge number by shifting a 1 bit left 100 places.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// In other words, the binary number that is 1 followed by 100 zeroes.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Big</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>Small</span> <span class=p>=</span> <span class=nx>Big</span> <span class=o>&gt;&gt;</span> <span class=mi>99</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>needInt</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span> <span class=k>return</span> <span class=nx>x</span><span class=o>*</span><span class=mi>10</span> <span class=o>+</span> <span class=mi>1</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>needFloat</span><span class=p>(</span><span class=nx>x</span> <span class=kt>float64</span><span class=p>)</span> <span class=kt>float64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>x</span> <span class=o>*</span> <span class=mf>0.1</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>needInt</span><span class=p>(</span><span class=nx>Small</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>needInt</span><span class=p>(</span><span class=nx>Big</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>needFloat</span><span class=p>(</span><span class=nx>Small</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>needFloat</span><span class=p>(</span><span class=nx>Big</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><strong>Short variable declarations</strong><ul><li><code>k := 3</code></li><li>只允许在函数内使用，需要初始化来进行类型推导</li></ul></li><li>Basic types<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>string</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span>  <span class=kt>int8</span>  <span class=kt>int16</span>  <span class=kt>int32</span>  <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=kt>uint</span> <span class=kt>uint8</span> <span class=kt>uint16</span> <span class=kt>uint32</span> <span class=kt>uint64</span> <span class=kt>uintptr</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>byte</span> <span class=c1>// alias for uint8
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>rune</span> <span class=c1>// alias for int32
</span></span></span><span class=line><span class=cl><span class=c1></span>     <span class=c1>// represents a Unicode code point
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>float32</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>complex64</span> <span class=kt>complex128</span>
</span></span></code></pre></div><ul><li>可以用 <code>%T</code> 来输出类型， <code>%v</code> 来输出值</li><li>like: <code>fmt.Printf("Type: %T Value: %v\n", MaxInt, MaxInt)</code></li></ul></li><li>type conversions (cast)<ul><li><code>T(v)</code></li></ul></li><li>loop<ul><li>只有一个loop结构： <code>for</code></li><li><strong>不用括号括起来</strong></li><li>传统for格式</li><li>只有 <code>;</code> 分隔</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>i</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>传统while格式</li><li>{{ 也就是while写成了for，并且不写括号</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>sum</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>sum</span> <span class=p>&lt;</span> <span class=mi>1000</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>sum</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>传统while(true) / forever 格式</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>if<ul><li>也没括号</li><li>但还有在判断前加一句执行语句的新奇if</li><li>这个语句定义的变量所在scope持续到 if 结束(包括后续的else)</li><li>{{ 正适合不想一个东西算两遍的场景</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 传统
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>x</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 维新
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>y</span> <span class=o>:=</span> <span class=nx>x</span><span class=o>-</span><span class=mi>100</span><span class=p>;</span> <span class=nx>y</span> <span class=p>&lt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>switch<ul><li><strong>只执行一个case，不用写break</strong></li><li><strong>cases 不需要是 const int</strong></li><li>{{ 好文明，好文明</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;Go runs on &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=nx>os</span> <span class=o>:=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>GOOS</span><span class=p>;</span> <span class=nx>os</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=s>&#34;darwin&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;OS X.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=s>&#34;linux&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Linux.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// freebsd, openbsd, plan9, windows...
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;%s.\n&#34;</span><span class=p>,</span> <span class=nx>os</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>从上到下执行，遇到匹配的就进去 (不会再执行后面case判断的计算)</li><li>switch with no condition</li><li>a clean way to write long if-then-else chains</li><li>因为现在case可以是判断语句了</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>t</span> <span class=o>:=</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Now</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>switch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Hour</span><span class=p>()</span> <span class=p>&lt;</span> <span class=mi>12</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Good morning!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nx>t</span><span class=p>.</span><span class=nf>Hour</span><span class=p>()</span> <span class=p>&lt;</span> <span class=mi>17</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Good afternoon.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;Good evening.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>defer<ul><li>压栈，推迟执行到scope结束</li><li>也因此是last-in-first-out</li><li>(pop 是 push 的<strong>倒序</strong>)</li><li>顺序上，是在 <code>return</code> 后执行</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;counting&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>**</span><span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span><span class=o>**</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;done&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 这个的输出是9 8 7 … 0
</span></span></span></code></pre></div><ul><li>只能defer函数调用</li><li>但结合匿名函数就等于没限制, like:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// whatever
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=p>()</span>
</span></span></code></pre></div></li></ul><p>more types: structs, slices, and maps.</p><ul><li>pointer<ul><li><strong>pointer 的 zero value 是 <code>nil</code></strong></li><li><del>什么年代还在写传统null</del></li><li><code>& *</code> 的操作与C一致</li><li>但不允许指针算数 (pointer arithmetic)</li></ul></li><li>struct<ul><li>注意前三句的语法</li><li><strong>指向struct的指针，访问field不用 <code>-></code> ，仍然用 <code>.</code></strong></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=o>**</span><span class=kd>type</span> <span class=nx>Vertex</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>X</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl>    <span class=nx>Y</span> <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>v1</span> <span class=o>:=</span> <span class=nx>Vertex</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>v2</span> <span class=o>:=</span> <span class=nx>Vertex</span><span class=p>{</span><span class=nx>X</span><span class=p>:</span> <span class=mi>1</span><span class=p>}</span><span class=o>**</span>
</span></span><span class=line><span class=cl><span class=nx>p</span> <span class=o>:=</span> <span class=o>&amp;</span><span class=nx>v1</span>
</span></span><span class=line><span class=cl><span class=o>**</span><span class=nx>p</span><span class=p>.</span><span class=nx>X</span><span class=o>**</span> <span class=p>=</span> <span class=mf>1e9</span>  <span class=c1>// not p-&gt;X
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>v</span><span class=p>)</span>
</span></span></code></pre></div></li><li>array <code>[n]T</code><ul><li>fixed size</li><li>用作size定义时写在前面，用作index访问时写在后面</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>[</span><span class=mi>2</span><span class=p>]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=p>=</span> <span class=s>&#34;Hello&#34;</span>
</span></span></code></pre></div></li><li>slice <code>[]T</code><ul><li>dynamically-sized</li><li>用 <code>a[low : high]</code> 来 refer to 一个array</li><li>省略 low/high 的 behavior 同 python, like <code>s[2:]</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>primes</span> <span class=o>:=</span> <span class=p>[</span><span class=mi>6</span><span class=p>]</span><span class=kt>int</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>13</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>=</span> <span class=nx>primes</span><span class=p>[</span><span class=mi>1</span><span class=p>:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=c1>// which is [3 5 7]
</span></span></span></code></pre></div><ul><li>是个reference (对其改动也反映在the underlying array上)</li><li>A slice does not store any data, it just describes a section of an underlying array.</li><li>slice literals</li><li><code>q := []int{2, 3, 5, 7, 11, 13}</code></li><li>这个的原理是先构造一个array，然后让slice refer to 它</li><li><code>len(s) cap(s)</code><ul><li>len 即 现在里面元素个数</li><li>cap 即 从现在的开头到结尾的个数</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>7</span><span class=p>,</span> <span class=mi>11</span><span class=p>,</span> <span class=mi>13</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>printSlice</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Slice the slice to give it zero length.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nf>printSlice</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Extend its length.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=nf>printSlice</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Drop its first two values.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=nf>printSlice</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printSlice</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;len=%d cap=%d %v\n&#34;</span><span class=p>,</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nb>cap</span><span class=p>(</span><span class=nx>s</span><span class=p>),</span> <span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>len=6 cap=6 [2 3 5 7 11 13]
</span></span></span><span class=line><span class=cl><span class=cm>len=0 cap=6 []
</span></span></span><span class=line><span class=cl><span class=cm>len=4 cap=6 [2 3 5 7]
</span></span></span><span class=line><span class=cl><span class=cm>len=2 cap=4 [5 7]
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div></li><li>空值也是 <code>nil</code><ul><li>length and capacity of 0</li><li>has no underlying array.</li></ul></li><li><code>make(s []T, len, cap) []T</code><ul><li>allocates a zeroed array and returns a slice that refers to that array</li><li>(最终作用类似C的malloc) (cap可以省略)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span> <span class=c1>// len(b)=0, cap(b)=5
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>[:</span><span class=nb>cap</span><span class=p>(</span><span class=nx>b</span><span class=p>)]</span> <span class=c1>// len(b)=5, cap(b)=5
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>[</span><span class=mi>1</span><span class=p>:]</span>      <span class=c1>// len(b)=4, cap(b)=4
</span></span></span></code></pre></div></li><li><code>append(s []T, vs ...T) []T</code><ul><li><code>**s = append(s, 2, 3, 4)**</code></li><li>如果空间不够会创建个更大的array</li><li>{{ 这里的写法感觉类似函数式编程 (append不会直接在s上做修改)</li><li>详细说明见：<a href=https://go.dev/pkg/builtin/#append>documentation</a> of the built-in package</li></ul></li></ul></li><li>range<ul><li>用range实现遍历 slice/map</li><li>每次迭代都给一对：index, value</li><li>类似python，不想要的可以用 <code>_</code> 来作placeholder</li><li>如果只写一个，得到的是index而非value (因为i在左)</li><li><code>for i := range pow</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>8</span><span class=p>,</span> <span class=mi>16</span><span class=p>,</span> <span class=mi>32</span><span class=p>,</span> <span class=mi>64</span><span class=p>,</span> <span class=mi>128</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>a</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;2**%d = %d\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>2**0 = 1
</span></span></span><span class=line><span class=cl><span class=cm>2**1 = 2
</span></span></span><span class=line><span class=cl><span class=cm>2**2 = 4
</span></span></span><span class=line><span class=cl><span class=cm>2**3 = 8
</span></span></span><span class=line><span class=cl><span class=cm>...
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span></code></pre></div></li><li>map<ul><li>和slice一样，也是个reference</li><li>空值也是 <code>nil</code></li><li>which has no keys, nor can keys be added.</li><li>类型声明 <code>map[kT]vT</code></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>Vertex</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>m</span><span class=p>[</span><span class=s>&#34;Bell Labs&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nx>Vertex</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=mf>40.68433</span><span class=p>,</span> <span class=o>-</span><span class=mf>74.39967</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>m</span><span class=p>[</span><span class=s>&#34;Bell Labs&#34;</span><span class=p>])</span>
</span></span></code></pre></div><ul><li>Insert or update an element in map <code>m</code>:</li><li><code>m[key] = elem</code></li><li>Retrieve an element:</li><li><code>elem = m[key]</code></li><li>Delete an element:</li><li><strong><code>delete(m, key)**</code></strong></li><li>Test that a key is present with a two-value assignment:</li><li><strong><code>elem, ok := m[key]</code></strong></li><li><code>ok</code> : true when key is in <code>m</code></li></ul></li><li>Func closure 闭包<ul><li>A closure is a function value that references variables from outside its body.</li><li>The function may access and assign to the referenced variables;
in this sense the function is &ldquo;bound&rdquo; to the variables.</li><li>{{ 感觉最终效果上就是能生成多个有自己的static var的函数</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>adder</span><span class=p>()</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>sum</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>sum</span> <span class=o>+=</span> <span class=nx>x</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>sum</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>pos</span><span class=p>,</span> <span class=nx>neg</span> <span class=o>:=</span> <span class=nf>adder</span><span class=p>(),</span> <span class=nf>adder</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span>
</span></span><span class=line><span class=cl>            <span class=nf>pos</span><span class=p>(</span><span class=nx>i</span><span class=p>),</span>
</span></span><span class=line><span class=cl>            <span class=nf>neg</span><span class=p>(</span><span class=o>-</span><span class=mi>2</span><span class=o>*</span><span class=nx>i</span><span class=p>),</span>
</span></span><span class=line><span class=cl>        <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>0 0
</span></span></span><span class=line><span class=cl><span class=cm>1 -2
</span></span></span><span class=line><span class=cl><span class=cm>3 -6
</span></span></span><span class=line><span class=cl><span class=cm>6 -12
</span></span></span><span class=line><span class=cl><span class=cm>10 -20
</span></span></span><span class=line><span class=cl><span class=cm>15 -30
</span></span></span><span class=line><span class=cl><span class=cm>...
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// for fibonacci (0, 1, 1, 2, 3, 5, ...)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>fibonacci</span><span class=p>()</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=o>:=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=kd>func</span><span class=p>()</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>oldA</span> <span class=o>:=</span> <span class=nx>a</span>
</span></span><span class=line><span class=cl>        <span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=p>=</span> <span class=nx>b</span><span class=p>,</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>oldA</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>f</span> <span class=o>:=</span> <span class=nf>fibonacci</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>f</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>先跳过了<ul><li><strong><a href=https://go.dev/tour/methods>Methods and interfaces</a></strong><ul><li>写method记得加 <code>*</code> ，保证在原对象上操作，而非copy一个</li></ul></li><li><strong><a href=https://go.dev/tour/generics>Generics</a></strong></li></ul></li></ul><h2 id=concurrency>Concurrency<a hidden class=anchor aria-hidden=true href=#concurrency>#</a></h2><ul><li><code>go f(x, y, z)</code><ul><li>启动新线程, called goroutine</li><li>x, y, z 的执行发生在current goroutine</li><li>f 的执行发生在new goroutine</li><li>goroutine 运行在相同的 address space<ul><li>因此需要 sync-ly 访问 shared mem</li></ul></li></ul></li><li>channel <code>chan</code><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// &#34;\\&#34;表示可选参数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>ch</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=err>\\</span><span class=nx>buf_len</span><span class=err>\\</span> <span class=p>)</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>v</span>    <span class=c1>// Send 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>v</span><span class=p>,</span> <span class=err>\\</span><span class=nx>ok</span><span class=err>\\</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>ch</span>  <span class=c1>// Receive and assign.
</span></span></span><span class=line><span class=cl><span class=c1></span>                                     <span class=c1>// ok=false means channel closed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>c</span>   <span class=c1>// receives values from the channel
</span></span></span><span class=line><span class=cl><span class=c1></span>                                     <span class=c1>// repeatedly **until it is closed.**
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span> <span class=c1>// close (better by sender, can be not necessary)
</span></span></span></code></pre></div><ul><li>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</li><li>channel如果不指定buffer，
必须要sender和receiver同时在等待的时候才能完成一次传输</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// error code (dead lock)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>test</span> <span class=o>:=</span> <span class=o>**</span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span><span class=o>**</span>
</span></span><span class=line><span class=cl><span class=nx>test</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span> <span class=o>&lt;-</span> <span class=nx>test</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// good code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>test</span> <span class=o>:=</span> <span class=o>**</span><span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span><span class=o>**</span>
</span></span><span class=line><span class=cl><span class=nx>test</span> <span class=o>&lt;-</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span> <span class=o>&lt;-</span> <span class=nx>test</span> <span class=p>)</span>
</span></span></code></pre></div><ul><li><input disabled type=checkbox> Q: 如果需要无限可拓展的buf怎么办？<ul><li>chan的元素类型改成数组？</li></ul></li></ul></li><li>select<div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nx>c</span> <span class=o>&lt;-</span> <span class=nx>x</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>x</span><span class=p>,</span> <span class=nx>y</span> <span class=p>=</span> <span class=nx>y</span><span class=p>,</span> <span class=nx>x</span><span class=o>+</span><span class=nx>y</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=o>&lt;-</span><span class=nx>quit</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;quit&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 跑一个匿名函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>10</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=o>&lt;-</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nx>quit</span> <span class=o>&lt;-</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=p>}()</span>
</span></span></code></pre></div><ul><li>case 语句都是 communication operations</li><li>select 会等到有可以run的，等到了就执行 (如果多个都可以run，那就随机选)</li><li>可以有 default:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>case</span> <span class=nx>i</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>c</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// use i
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>// receiving from c would block
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>一个channel范例程序<ul><li>教程里的题目，自己写的代码</li><li>判断两个树的中序遍历是否相同</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;golang.org/x/tour/tree&#34;</span>
</span></span><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>type Tree struct {
</span></span></span><span class=line><span class=cl><span class=cm>    Left  *Tree
</span></span></span><span class=line><span class=cl><span class=cm>    Value int
</span></span></span><span class=line><span class=cl><span class=cm>    Right *Tree
</span></span></span><span class=line><span class=cl><span class=cm>}
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Walk walks the tree t sending all values
</span></span></span><span class=line><span class=cl><span class=c1>// from the tree to the channel ch.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Walk</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>tree</span><span class=p>.</span><span class=nx>Tree</span><span class=p>,</span> <span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>recWalk</span><span class=p>(</span><span class=nx>t</span><span class=p>,</span> <span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>close</span><span class=p>(</span><span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>recWalk</span><span class=p>(</span><span class=nx>t</span> <span class=o>*</span><span class=nx>tree</span><span class=p>.</span><span class=nx>Tree</span><span class=p>,</span> <span class=nx>ch</span> <span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>t</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=nf>recWalk</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Left</span><span class=p>,</span> <span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch</span> <span class=o>&lt;-</span> <span class=nx>t</span><span class=p>.</span><span class=nx>Value</span>
</span></span><span class=line><span class=cl>    <span class=nf>recWalk</span><span class=p>(</span><span class=nx>t</span><span class=p>.</span><span class=nx>Right</span><span class=p>,</span> <span class=nx>ch</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Same determines whether the trees
</span></span></span><span class=line><span class=cl><span class=c1>// t1 and t2 contain the same values.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Same</span><span class=p>(</span><span class=nx>t1</span><span class=p>,</span> <span class=nx>t2</span> <span class=o>*</span><span class=nx>tree</span><span class=p>.</span><span class=nx>Tree</span><span class=p>)</span> <span class=kt>bool</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch1</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>ch2</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>Walk</span><span class=p>(</span><span class=nx>t1</span><span class=p>,</span> <span class=nx>ch1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>Walk</span><span class=p>(</span><span class=nx>t2</span><span class=p>,</span> <span class=nx>ch2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>i</span><span class=p>,</span> <span class=nx>ok1</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>ch1</span>
</span></span><span class=line><span class=cl>        <span class=nx>j</span><span class=p>,</span> <span class=nx>ok2</span> <span class=o>:=</span> <span class=o>&lt;-</span> <span class=nx>ch2</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>ok1</span><span class=o>==</span><span class=kc>false</span> <span class=o>&amp;&amp;</span> <span class=nx>ok2</span><span class=o>==</span><span class=kc>false</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// both closed
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=nx>ok1</span><span class=o>||</span><span class=nx>ok2</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=p>!(</span><span class=nx>ok1</span><span class=o>&amp;&amp;</span><span class=nx>ok2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// not same length
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;i: &#34;</span><span class=p>)</span> <span class=c1>// for debug
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=nx>i</span><span class=p>)</span> <span class=c1>// for debug
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;, j: &#34;</span><span class=p>)</span> <span class=c1>// for debug
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>j</span><span class=p>)</span> <span class=c1>// for debug
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>i</span><span class=o>!=</span><span class=nx>j</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=o>:=</span> <span class=nf>Same</span><span class=p>(</span><span class=nx>tree</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=nx>tree</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=p>=</span> <span class=nf>Same</span><span class=p>(</span><span class=nx>tree</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>1</span><span class=p>),</span> <span class=nx>tree</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>res</span> <span class=p>=</span> <span class=nf>Same</span><span class=p>(</span><span class=nx>tree</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>2</span><span class=p>),</span> <span class=nx>tree</span><span class=p>.</span><span class=nf>New</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>res</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul></li><li>sync.Mutex<ul><li>提供了两个方法 <code>Lock</code> <code>Unlock</code> (包含的部分即原子化)</li><li>可以利用 <code>defer</code> 把return语句也包含在原子操作里 (例如下面的<strong>Value</strong>函数)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// SafeCounter is safe to use concurrently.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>SafeCounter</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span>
</span></span><span class=line><span class=cl>    <span class=nx>v</span>  <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>**</span><span class=c1>// Inc increments the counter for the given key.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>SafeCounter</span><span class=p>)</span> <span class=nf>Inc</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Lock so only one goroutine at a time can access the map c.v.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>c</span><span class=p>.</span><span class=nx>v</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span><span class=o>++</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Value returns the current value of the counter for the given key.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>SafeCounter</span><span class=p>)</span> <span class=nf>Value</span><span class=p>(</span><span class=nx>key</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Lock so only one goroutine at a time can access the map c.v.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>defer</span> <span class=nx>c</span><span class=p>.</span><span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>c</span><span class=p>.</span><span class=nx>v</span><span class=p>[</span><span class=nx>key</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>}</span><span class=o>**</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=o>:=</span> <span class=nx>SafeCounter</span><span class=p>{</span><span class=nx>v</span><span class=p>:</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1000</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nx>c</span><span class=p>.</span><span class=nf>Inc</span><span class=p>(</span><span class=s>&#34;somekey&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nf>Value</span><span class=p>(</span><span class=s>&#34;somekey&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li>一个 <code>channel & sync.Mutex</code> 范例<ul><li><a href=https://go.dev/tour/concurrency/10>A Tour of Go</a> 教程里的一个并行 Web Crawler (网页爬虫)</li><li>这里 <code>map</code> 其实就当做 <code>set</code> 用了<ul><li>语言内置类型好像是没有set的</li><li>但查到 <code>golang-set</code> 这个包还提供了线程安全的 <code>set</code></li></ul></li><li>go 的 <code>map</code> 不是线程安全的 (not safe for concurrent use)，
需要一个mutex保护它</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;sync&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Fetcher</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Fetch returns the body of URL and
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// a slice of URLs found on that page.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Fetch</span><span class=p>(</span><span class=nx>url</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>body</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>urls</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Crawl uses fetcher to recursively crawl
</span></span></span><span class=line><span class=cl><span class=c1>// pages starting with url, to a maximum of depth.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>Crawl</span><span class=p>(</span><span class=nx>url</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>depth</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>fetcher</span> <span class=nx>Fetcher</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=kd>var</span> <span class=nx>mu</span> <span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span> <span class=c1>// protects the map
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>go</span> <span class=nf>recCrawl</span><span class=p>(</span><span class=nx>url</span><span class=p>,</span> <span class=nx>depth</span><span class=p>,</span> <span class=nx>fetcher</span><span class=p>,</span> <span class=nx>m</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>mu</span><span class=p>,</span> <span class=nx>done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>&lt;-</span> <span class=nx>done</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>recCrawl</span><span class=p>(</span><span class=nx>url</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>depth</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>fetcher</span> <span class=nx>Fetcher</span><span class=p>,</span> <span class=nx>m</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>bool</span><span class=p>,</span> <span class=nx>mu</span> <span class=o>*</span><span class=nx>sync</span><span class=p>.</span><span class=nx>Mutex</span><span class=p>,</span> <span class=nx>done</span> <span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// defer真好用    
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>done</span> <span class=o>&lt;-</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;--- done: %s\n&#34;</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;--- fetch: %s\n&#34;</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nx>m</span><span class=p>[</span><span class=nx>url</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
</span></span><span class=line><span class=cl>    <span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>depth</span> <span class=o>&lt;=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>body</span><span class=p>,</span> <span class=nx>urls</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>fetcher</span><span class=p>.</span><span class=nf>Fetch</span><span class=p>(</span><span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;found: %s %q\n&#34;</span><span class=p>,</span> <span class=nx>url</span><span class=p>,</span> <span class=nx>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>_done</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>bool</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>needDone</span> <span class=o>:=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>u</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>urls</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>mu</span><span class=p>.</span><span class=nf>Lock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=nx>_</span><span class=p>,</span> <span class=nx>exist</span> <span class=o>:=</span> <span class=nx>m</span><span class=p>[</span><span class=nx>u</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=nx>mu</span><span class=p>.</span><span class=nf>Unlock</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fmt.Printf(&#34;--- exist?: %V\n&#34;, exist)
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=nx>exist</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;--- fetched before: %s\n&#34;</span><span class=p>,</span> <span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;--- to: %s\n&#34;</span><span class=p>,</span> <span class=nx>u</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>needDone</span><span class=o>++</span>
</span></span><span class=line><span class=cl>        <span class=k>go</span> <span class=nf>recCrawl</span><span class=p>(</span><span class=nx>u</span><span class=p>,</span> <span class=nx>depth</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>fetcher</span><span class=p>,</span> <span class=nx>m</span><span class=p>,</span> <span class=nx>mu</span><span class=p>,</span> <span class=nx>_done</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>i</span><span class=o>:=</span><span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=p>&lt;</span><span class=nx>needDone</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=o>&lt;-</span> <span class=nx>_done</span>
</span></span><span class=line><span class=cl>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;--- get one done: %d %s\n&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Crawl</span><span class=p>(</span><span class=s>&#34;https://golang.org/&#34;</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=nx>fetcher</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fakeFetcher is Fetcher that returns canned results.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>fakeFetcher</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=o>*</span><span class=nx>fakeResult</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>fakeResult</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>body</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=nx>urls</span> <span class=p>[]</span><span class=kt>string</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=nx>fakeFetcher</span><span class=p>)</span> <span class=nf>Fetch</span><span class=p>(</span><span class=nx>url</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>res</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>f</span><span class=p>[</span><span class=nx>url</span><span class=p>];</span> <span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nx>res</span><span class=p>.</span><span class=nx>body</span><span class=p>,</span> <span class=nx>res</span><span class=p>.</span><span class=nx>urls</span><span class=p>,</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=kc>nil</span><span class=p>,</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Errorf</span><span class=p>(</span><span class=s>&#34;not found: %s&#34;</span><span class=p>,</span> <span class=nx>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// fetcher is a populated fakeFetcher.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>fetcher</span> <span class=p>=</span> <span class=nx>fakeFetcher</span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;https://golang.org/&#34;</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>fakeResult</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;The Go Programming Language&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/pkg/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/cmd/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;https://golang.org/pkg/&#34;</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>fakeResult</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;Packages&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/cmd/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/pkg/fmt/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/pkg/os/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;https://golang.org/pkg/fmt/&#34;</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>fakeResult</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;Package fmt&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/pkg/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;https://golang.org/pkg/os/&#34;</span><span class=p>:</span> <span class=o>&amp;</span><span class=nx>fakeResult</span><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=s>&#34;Package os&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>[]</span><span class=kt>string</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;https://golang.org/pkg/&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>},</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li></ul><h2 id=go-further>Go further<a hidden class=anchor aria-hidden=true href=#go-further>#</a></h2><p><strong>Where to Go from here</strong></p><p>You can get started by <a href=https://go.dev/dl/>installing Go</a>.</p><p>Once you have Go installed, the <a href=https://go.dev/doc/>Go Documentation</a> is a great place to continue. It contains references, tutorials, videos, and more.</p><p>To learn how to organize and work with Go code, read <a href=https://go.dev/doc/code>How to Write Go Code</a>.</p><p>If you need help with the standard library, see the <a href=https://go.dev/pkg/>package reference</a>. For help with the language itself, you might be surprised to find the <a href=https://go.dev/ref/spec>Language Spec</a> is quite readable.</p><p>To further explore Go&rsquo;s concurrency model, watch <a href="https://www.youtube.com/watch?v=f6kdp27TYZs">Go Concurrency Patterns</a> (<a href=https://go.dev/talks/2012/concurrency.slide>slides</a>) and <a href="https://www.youtube.com/watch?v=QDDwwePbDtw">Advanced Go Concurrency Patterns</a> (<a href=https://go.dev/talks/2013/advconc.slide>slides</a>) and read the <a href=https://go.dev/doc/codewalk/sharemem/>Share Memory by Communicating</a> codewalk.</p><p>To get started writing web applications, watch <a href=https://vimeo.com/53221558>A simple programming environment</a> (<a href=https://go.dev/talks/2012/simple.slide>slides</a>) and read the <a href=https://go.dev/doc/articles/wiki/>Writing Web Applications</a> tutorial.</p><p>The <a href=https://go.dev/doc/codewalk/functions/>First Class Functions in Go</a> codewalk gives an interesting perspective on Go&rsquo;s function types.</p><p>The <a href=https://go.dev/blog/>Go Blog</a> has a large archive of informative Go articles.</p><p>Visit <a href=https://go.dev/>the Go home page</a> for more.</p><h1 id=other>Other<a hidden class=anchor aria-hidden=true href=#other>#</a></h1><h2 id=some-details>Some details<a hidden class=anchor aria-hidden=true href=#some-details>#</a></h2><ul><li><code>fmt.Print</code><ul><li>相关函数<ul><li><code>Println</code></li><li><code>Printf</code></li></ul></li><li>输出控制<ul><li><code>%v</code> 对啥类型都适用</li></ul></li></ul></li></ul><h2 id=tag>Tag<a hidden class=anchor aria-hidden=true href=#tag>#</a></h2><p>序列化中常用</p><ul><li><input disabled type=checkbox> TODO: learn</li><li>Tag原理<ul><li><a href=https://zhuanlan.zhihu.com/p/260642112>Golang 中的标签（Tags in Golang） - 知乎 (zhihu.com)</a></li></ul></li><li>Json中的Tag<ul><li><a href=https://fivezh.github.io/2022/02/01/golang-json-tag/>GoLang 中 Json Tag用法汇总 | 小武的博客 (fivezh.github.io)</a></li></ul></li><li>SQL数据库ORM中的Tag<ul><li><a href=https://blog.csdn.net/weixin_40626064/article/details/119242905>[GO] gorm的字段标签_我要努力向上的博客-CSDN博客_gorm tag</a></li></ul></li></ul><h2 id=golang后端常类库>Golang后端常⽤类库<a hidden class=anchor aria-hidden=true href=#golang后端常类库>#</a></h2><ul><li>配置⽂件：Viper</li><li>序列化：⾃带的 encoding/json</li><li>服务器框架：gin，echo等</li><li>数据库访问：go-mongo gorm等（之后会结合数据库章节细讲）</li><li>⽹络请求： http</li><li>⽇志系统：logrus</li></ul><h2 id=avoid-mem-leak>Avoid Mem Leak<a hidden class=anchor aria-hidden=true href=#avoid-mem-leak>#</a></h2><p><a href=https://go101.org/article/memory-leaking.html>Memory Leaking Scenarios -Go 101</a></p><ol><li><strong>Substrings</strong></li><li><strong>Subslices</strong></li><li><strong>Not resetting pointers in lost slice elements</strong></li><li><strong>Hanging Goroutines</strong></li></ol><ul><li>其他<ol><li>not stopping time.Ticker values which are not used any more</li><li>using finalizers improperly</li><li>deferring function calls</li></ol></li><li>问题排查：使用pprof<ul><li><a href=https://www.hitzhangjie.pro/blog/2021-04-14-go%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D/>Go程序内存泄露问题快速定位 - MySpace (hitzhangjie.pro)</a></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/golang/>Golang</a></li><li><a href=http://localhost:1313/tags/note/>Note</a></li><li><a href=http://localhost:1313/tags/tech/>Tech</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang Note on x" href="https://x.com/intent/tweet/?text=Golang%20Note&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f&amp;hashtags=Golang%2cNote%2cTech"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang Note on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f&amp;title=Golang%20Note&amp;summary=Golang%20Note&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang Note on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f&title=Golang%20Note"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang Note on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang Note on whatsapp" href="https://api.whatsapp.com/send?text=Golang%20Note%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang Note on telegram" href="https://telegram.me/share/url?text=Golang%20Note&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Golang Note on ycombinator" href="https://news.ycombinator.com/submitlink?t=Golang%20Note&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang-notes%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Jyu'Log</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>